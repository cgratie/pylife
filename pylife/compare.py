# -*- coding: utf-8 -*-

# pylife
# 
# Copyright (c) 2018 Cristian Gratie
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

from __future__ import absolute_import, division, print_function
from builtins import (ascii, bytes, chr, dict, filter, hex, input,
                      int, map, next, oct, open, pow, range, round,
                      str, super, zip)

import numpy as np

from . import rules, environment, game


def test_rules(rows, cols, num_states, neighbors, rules_gen, steps):
    results = {}
    for rule in rules_gen:
        name = rules.rule_to_name(rule)

        msg = ""
        msg += "distinct: {}, current: {}\n".format(len(results), name)
        msg += "\n"
        for n, v in sorted(results.items(), key=lambda x: -x[1])[:50]:
            msg += "{}: {}\n".format(n, v)
        msg += (2 + min(50, len(results))) * "\033[F"
        print(msg, end="")

        means = []
        prevs = []
        state, core = game.create(rows, cols, num_states)
        for step in range(steps):
            game.wrap(state)
            nb = neighbors(state)
            core[...] = rule[(core,) + nb]
            found = False
            for val in range(1, num_states):
                if np.all(core == val) or not np.any(core == val):
                    found = True
                    break
            if found:
                break
            found = False
            for s in prevs:
                if np.all(s == core):
                    found = True
                    break
            if found:
                break

            prevs.append(core.copy())
            means.append((core > 0).mean())
            if step > 350 and np.mean(means[-50:]) > 0.2:
                step = 0
                break
        if np.mean(means[-50:]) > 0.2:
            step = 0
        if name in results:
            results[name] = max(results[name], step)
        else:
            results[name] = step


names_n4m = """
00100.00221.00220
00100.00101.00222
00200.00200.00221
"""

names_n4s = """
0011000012220222111200000.0012002020120020100202022.0020201222201122201000112: 999
0002200211110221021200000.0021201222020101012110111.0022102120000102120202212: 999
0011000000221002012200000.0000102010122002200010002.0002101200000211110022020: 999
0001002001112211000000000.0002201010101012002201202.0011000210010001012110000: 999
0022001000020002101100000.0010001210021000001201020.0002202212101000020102021: 999
0022101221000222120100000.0020001212020201112122121.0001001012111020201122101: 999
0022001221001100002100000.0011001202122000211101121.0001201020110010022221020: 999
0021200202112221012100000.0021001111220110020010221.0002102011211121002120222: 999
0020100201011112212000000.0020201211101212112021120.0022001210220011200101222: 999
0000200222112021121200000.0012002201110012200002021.0010002001202122122011011: 999
0022000001101101211000000.0022202201002220220101011.0001102202112022122220210: 999
0020000121101011222000000.0001201021211222200000211.0020000101121001100211002: 999
0021002012112111000100000.0020201002120002012001021.0021100201021121000012020: 999
0022200210111102221100000.0021200120020210122121002.0001102120102111120002100: 999
0022000200000010121100000.0021202102110120000021222.0021101112111000212100122: 999
0020002001111001010000000.0020200112021200222022020.0020101000102000022001021: 999
0020201220012201202200000.0010100120210221111210121.0002202200100220010101112: 999
0011000000222222020200000.0022201001100001020011020.0021100211220222101110010: 999
0000101022121001221100000.0021100011111102011200211.0011102000122001200211220: 999
0022100212011210212000000.0000202201110202210212010.0022100220220210122210112: 999
0022100222101100102200000.0002102101202010000210112.0022001210211011212000001: 999
0020202001111111001000000.0011100221012222210120110.0021201122001102201010010: 999
0021000101120101010000000.0012000122001201112020021.0000200110112000021201002: 999
0022000020101212201000000.0020102012210011111000201.0011100122021022001001002: 999
0020000022100210220000000.0021001112221122011121202.0021001200212221012202102: 999
0020200010101121112000000.0000200102110211110022020.0021202220200200201210010: 999
0020000221100201120000000.0001102100012022010011212.0012101102220101000112121: 999
0000002122110001022200000.0021200022000110002000211.0020002011200121211010101: 999
0020200002100021022200000.0020100021220100122221112.0021101000100021121000202: 999
0020200121102201200200000.0020001120200011021020021.0002102022112111100210022: 999
0022200212012110101200000.0002100012020100101111201.0011200021012222222022110: 903
0011001010110002002000000.0000200202011120110021220.0022200002212021210102211: 903
0000102001110121022100000.0021201210201002101222101.0001101020201111001001102: 863
0020001221112101221100000.0002002120202222012122111.0010101021012011012211222: 862
0000201110210101220000000.0011102001020210210121021.0010100000020012002220210: 807

0010100021110022022200000.0010002211111211122020210.0002002022220201122100011: 499
""".strip()

names_n8m_old = """
000101010.001100001: 999
000101100.001100000: 999
000100000.001100000: 999
000100011.001100011: 999
000100011.001100010: 999
000100100.001100011: 999
000100001.001100001: 999
000100010.001100001: 999
000100010.001100000: 999
000101011.001100001: 999
000101011.001100000: 999
000100111.001100000: 999
000100101.001100000: 999
000100101.001100001: 999
000100000.001100011: 999
000100000.001100010: 999
000100100.001100001: 999
000100011.001100000: 999
000100011.001100001: 999
000100110.001100000: 999
000100110.001100001: 999
000100001.001100010: 999
000100001.001100011: 999
000100010.001100010: 999
000100010.001100011: 999
000100001.001100000: 992
000100100.001100000: 922
000100100.001100010: 878
000100111.001100001: 841
000101010.001100000: 796
000101000.001100010: 701
000100111.001100010: 637
000100000.001100001: 623
000100101.001100011: 586
000101001.001100001: 584
000100111.000011110: 554
000101000.001100000: 550
000100011.001011101: 543
000100010.001011100: 521
000101001.001100000: 515
000100110.001100010: 475
000101000.001100001: 466
000100101.001100010: 454
000100010.001011101: 445
000101111.001010001: 443
000101011.001010100: 432
000101101.001010011: 431
000101101.000101100: 419
000101100.000110010: 416
000101000.001010100: 416
""".strip()

names_n8m = """
000010011.110101111: 999
000100100.001100010: 999
000100000.001100010: 999
000100001.001100011: 999
000100010.001100010: 999
000100010.001100011: 999
000100011.001100011: 999
000100100.001100000: 999
000100110.001100001: 999
000100111.001100000: 999
000100110.001100000: 968
000100011.011001100: 916
000100010.001100000: 910
000100011.001100001: 874
000100010.011001110: 855
000100000.001100011: 771
000100000.110101000: 734
000101000.110100001: 710
000101011.001100000: 705
000100010.001100001: 701
000100101.011001000: 687
000100001.001100010: 664
000100010.110101011: 643
000100000.101011101: 628
000101000.001100001: 614
000100110.011001000: 603
000101000.110100000: 594
000100011.011001111: 580
000100101.001100010: 575
000100000.011001011: 572
000100001.110101000: 566
000110111.101000001: 558
000100011.001100000: 548
000101010.001100000: 548
000110011.110000101: 532
000110011.110000100: 526
000100000.110101001: 524
000010100.011110000: 514
000110000.110000100: 509
000100100.011001010: 508
000010010.111101001: 492
000101100.010100111: 485
000110000.110000110: 485
000100001.001100001: 484
000101001.101010011: 479
000110010.110000111: 478
000100010.001011100: 477
000100001.110101001: 474
000101111.110010101: 464
000100001.110101010: 464

000100000.001100010: 999
000100111.001100001: 999
000100011.001100000: 764
000100100.011001000: 720
000100000.110101010: 592
000010110.111101001: 537
000100110.011001001: 521
000100000.001100000: 509
000110011.110000101: 492
000100001.110101001: 484
000100010.110101000: 468
000101000.110100001: 457
000100001.011001101: 451
000100100.001100011: 434
000101010.101010010: 431
000101100.010100111: 426
000110001.110000100: 420
000110111.001000011: 419
000010101.101110101: 411
000011100.011100110: 410
000100000.001100011: 409
000101010.001010110: 407
000100010.001011100: 406
000101100.101010001: 406
000101011.101010010: 406
000100100.001100000: 406
000010110.001110101: 406
000100001.001100001: 404
000110011.110000111: 401
000101010.001100001: 399
000111010.001000000: 399
000101111.101001100: 396
000011010.111100101: 396
000010001.101110100: 395
000110000.101000100: 394
000101010.110011000: 394
000110111.100010001: 393
000010100.011110000: 389
000100001.001100011: 389
000100011.110101001: 384
000100110.011001011: 383
000011010.001110011: 382
000010010.110111010: 382
000101000.110100000: 381
000100111.000101111: 381
000011000.011101011: 379
000101110.100101010: 376
000110000.010010011: 376
000101100.000101100: 375
000101111.001010001: 372

000101100.001100000: 999
000100011.001100011: 999
000100010.001100000: 999
000101011.001100001: 999
000100110.001100001: 999
000100000.001100010: 999
000100011.001100000: 999
000100001.001100011: 999
000100010.001100010: 999
000100010.001100011: 999
000100101.001100000: 957
000100111.001100001: 927
000101010.001100000: 803
000100010.001100001: 799
000100000.001100011: 762
000100001.001100010: 606
000100111.001100000: 603
000100000.001100000: 556
000100100.001100000: 528
000101010.001100001: 522
000101001.001100000: 519
000100100.001100001: 502
000100011.001011101: 493
000100010.001011101: 473
000010011.001110111: 468
000100100.001100011: 466
000010010.001110110: 432
000101101.001100000: 418
000011010.001110011: 410
000111001.000100001: 406
000101001.001100001: 405
000100111.001011011: 404
000101011.001010101: 400
000010110.000111100: 399
000100101.001100001: 396
000010000.001110101: 394
000011011.001110011: 390
000101010.001010100: 389
000101001.001010111: 388
000100110.001011010: 385
000010100.001110101: 383
000111000.000100001: 382
000010111.001110101: 376
000101001.000011101: 375
000111001.000100000: 374
000110010.000011001: 374
000101100.001010010: 373
000101101.001010010: 370
000100001.001100000: 368
000011110.001101010: 367
""".strip()


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("rule", type=int)
    args = parser.parse_args()
    if args.rule >= 0:
        name = names_n8m.split("\n")[args.rule].split(": ")[0]
        game.play(
            50, 100,
            ["  ", "# "],
            environment.n8binary,
            rules.name_to_rule(name, shape=(2, 9)),
        )
    else:
        test_rules(25, 25, 2, environment.n8binary, rules.all_rules((2, 9)), 1000)
